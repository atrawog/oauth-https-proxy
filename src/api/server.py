"""FastAPI server setup for the API component."""

import os
import logging
import asyncio
from contextlib import asynccontextmanager
from typing import Optional

from fastapi import FastAPI, Request, Depends, HTTPException
from fastapi.responses import HTMLResponse, PlainTextResponse
from fastapi.staticfiles import StaticFiles
from fastapi.middleware.cors import CORSMiddleware
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.datastructures import URL, Headers, MutableHeaders

from .models import HealthStatus
from ..shared.client_ip import get_real_client_ip

# OAuth imports
from .oauth.config import Settings as OAuthSettings
from .oauth.redis_client import RedisManager as OAuthRedisManager
from .oauth.auth_authlib import AuthManager
from .oauth.routes import create_oauth_router

logger = logging.getLogger(__name__)


class DisconnectHandlerMiddleware(BaseHTTPMiddleware):
    """Safety net middleware to catch any remaining disconnect issues we haven't fixed yet.
    
    This should NOT be catching things in normal operation. If it does, we have
    more bugs to fix properly instead of just suppressing them.
    """
    
    async def dispatch(self, request: Request, call_next):
        """Handle request and catch disconnect-related exceptions as a safety net."""
        try:
            response = await call_next(request)
            return response
        except asyncio.CancelledError:
            # This should be handled properly in the actual handlers now
            logger.warning(f"SAFETY NET: Caught unhandled CancelledError for {request.url.path} - FIX THE HANDLER!")
            return PlainTextResponse("", status_code=499)
        except (ConnectionResetError, BrokenPipeError, ConnectionAbortedError) as e:
            # These should be handled in the actual handlers
            logger.warning(f"SAFETY NET: Caught unhandled {type(e).__name__} for {request.url.path} - FIX THE HANDLER!")
            return PlainTextResponse("", status_code=499)
        except GeneratorExit:
            # Generator cleanup should be handled properly
            logger.warning(f"SAFETY NET: Caught unhandled GeneratorExit for {request.url.path} - FIX THE HANDLER!")
            return PlainTextResponse("", status_code=499)
        except Exception as e:
            # Check if this is a wrapped disconnect exception
            error_str = str(e).lower()
            if any(x in error_str for x in ['disconnect', 'cancelled', 'broken pipe', 'connection reset']):
                logger.warning(f"SAFETY NET: Caught wrapped disconnect ({type(e).__name__}) for {request.url.path} - FIX THE HANDLER!")
                return PlainTextResponse("", status_code=499)
            # Check for the specific MCP error that we should have fixed
            if "Unexpected message received: http.request" in str(e):
                logger.error(f"SAFETY NET: MCP SSE bug NOT FIXED! Still catching error for {request.url.path}")
                return PlainTextResponse("", status_code=499)
            # Re-raise real errors
            raise


class ProxyHeadersMiddleware(BaseHTTPMiddleware):
    """Middleware to handle X-Forwarded headers when behind a proxy.
    
    This ensures FastAPI generates correct redirect URLs using the external
    hostname instead of internal Docker proxy_hostnames.
    """
    
    async def dispatch(self, request: Request, call_next):
        # Get forwarded headers
        forwarded_proto = request.headers.get("x-forwarded-proto")
        forwarded_host = request.headers.get("x-forwarded-host") or request.headers.get("host")
        
        # If we have forwarded headers, reconstruct the URL
        if forwarded_host:
            # Build the correct external URL
            scheme = forwarded_proto or request.url.scheme
            
            # Parse the current URL
            url = request.url
            
            # Create new URL with external host
            # This ensures any redirects generated by FastAPI use the correct external URL
            request.scope["scheme"] = scheme
            if ":" in forwarded_host:
                host, port_str = forwarded_host.split(":", 1)
                try:
                    port = int(port_str)
                except ValueError:
                    host = forwarded_host
                    port = 443 if scheme == "https" else 80
            else:
                host = forwarded_host
                port = 443 if scheme == "https" else 80
            
            # Update the scope to reflect the external URL
            request.scope["server"] = (host, port)
            
            # Also update headers to ensure consistency
            headers = MutableHeaders(scope=request.scope)
            headers["host"] = forwarded_host
        
        response = await call_next(request)
        return response


def create_api_app(storage, cert_manager, scheduler) -> FastAPI:
    """Create the FastAPI application."""
    
    # Initialize OAuth components
    oauth_settings = OAuthSettings()
    oauth_redis_manager = OAuthRedisManager(oauth_settings)
    auth_manager = AuthManager(oauth_settings)
    
    @asynccontextmanager
    async def lifespan(app: FastAPI):
        """Manage application lifecycle."""
        logger.info("API app starting...")
        # Initialize OAuth Redis connection
        await oauth_redis_manager.initialize()
        
        # Initialize OAuth resource protector (not stored in app.state)
        from .oauth.async_resource_protector import create_async_resource_protector
        resource_protector = create_async_resource_protector(
            oauth_settings,
            oauth_redis_manager.client,
            auth_manager.key_manager
        )
        
        yield
        logger.info("API app shutting down...")
        # Close OAuth Redis connection
        await oauth_redis_manager.close()
    
    app = FastAPI(
        title="MCP HTTP Proxy API",
        description="Certificate and proxy management API",
        version="1.0.0",
        lifespan=lifespan,
        redirect_slashes=False  # Disabled to prevent /mcp -> /mcp/ redirects
    )
    
    # Store dependencies
    app.state.storage = storage
    app.state.cert_manager = cert_manager
    app.state.scheduler = scheduler
    
    # OAuth components are initialized but not stored in app.state
    # They're only used during startup for initialization
    
    # CRITICAL: Add ProxyHeadersMiddleware FIRST to fix redirect URLs
    # This must be added before any other middleware to ensure request.url
    # reflects the external URL, not the internal Docker URL
    app.add_middleware(ProxyHeadersMiddleware)
    
    # Add AuthConfigMiddleware to capture full request paths
    # This must be added early to ensure paths are captured before routing
    from .auth_middleware import AuthConfigMiddleware
    app.add_middleware(AuthConfigMiddleware)
    
    # Add UnifiedLoggingMiddleware for fire-and-forget logging
    # This must be added after AuthConfigMiddleware to capture auth info
    from ..middleware.unified_logging_middleware import UnifiedLoggingMiddleware
    app.add_middleware(UnifiedLoggingMiddleware)
    
    # Add CORS middleware
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )
    
    # Add disconnect handler middleware as the outermost layer (added last = runs first)
    # This catches all disconnect exceptions before they bubble up and crash the ASGI framework
    app.add_middleware(DisconnectHandlerMiddleware)
    
    # Add middleware to identify instance
    @app.middleware("http")
    async def add_instance_name(request: Request, call_next):
        response = await call_next(request)
        response.headers["X-Instance-Name"] = "api"
        return response
    
    # Mount static files
    static_path = os.path.join(os.path.dirname(__file__), "static")
    app.mount("/static", StaticFiles(directory=static_path), name="static")
    
    # Root endpoint - serve web GUI
    @app.get("/")
    async def read_root():
        """Serve the main web interface."""
        index_path = os.path.join(static_path, "index.html")
        if os.path.exists(index_path):
            with open(index_path, "r") as f:
                return HTMLResponse(content=f.read())
        return HTMLResponse(content="<h1>MCP HTTP Proxy</h1>")
    
    # Health check endpoint
    @app.get("/health", response_model=HealthStatus)
    async def health_check(request: Request):
        """Health check endpoint with async architecture."""
        try:
            # Get async components from app state
            # Always use async storage - no fallback
            async_storage = request.app.state.async_storage
            
            # Use async storage for all operations
            certs = await async_storage.list_certificates()
            
            # Count orphaned resources
            orphaned_count = 0
            # Check for orphaned proxy certificates
            proxy_targets = await async_storage.list_proxy_targets()
            proxy_certs = {target.cert_name for target in proxy_targets if target.cert_name}
            all_certs = {cert.cert_name for cert in certs}
            orphaned_certs = all_certs - proxy_certs - {"localhost-self-signed"}
            orphaned_count += len(orphaned_certs)
            
            # Check stream consumer health if available
            consumer_healthy = True
            if hasattr(request.app.state, 'metrics_processor') and request.app.state.metrics_processor:
                try:
                    lag = await request.app.state.metrics_processor.get_lag()
                    max_lag = max(lag.values()) if lag else 0
                    consumer_healthy = max_lag < 1000  # Less than 1 second
                except:
                    pass
            
            # Check Redis health
            redis_healthy = await async_storage.health_check()
            
            return HealthStatus(
                status="healthy" if redis_healthy and consumer_healthy else "degraded",
                scheduler=request.app.state.scheduler.is_running(),
                redis="healthy" if redis_healthy else "unhealthy",
                certificates_loaded=len(certs),
                https_enabled=len(certs) > 0,
                orphaned_resources=orphaned_count
            )
        except Exception as e:
            logger.error(f"Health check failed: {e}")
            raise HTTPException(status_code=500, detail=str(e))
    
    # ACME challenge endpoint
    @app.get("/.well-known/acme-challenge/{token}", response_class=PlainTextResponse)
    async def acme_challenge(token: str, request: Request):
        """Handle ACME challenge validation with async storage."""
        # Always use async storage - no fallback
        authorization = await request.app.state.async_storage.get_challenge(token)
        
        if authorization:
            logger.info(f"ACME challenge served for token: {token}")
            return PlainTextResponse(authorization)
        else:
            logger.warning(f"ACME challenge not found for token: {token}")
            raise HTTPException(status_code=404, detail="Challenge not found")
    
    # Test endpoint
    @app.get("/test-logging")
    async def test_logging():
        """Test endpoint to verify logging works."""
        logger.info("Test logging endpoint called")
        logger.debug("Debug message")
        logger.warning("Warning message")
        return {"status": "ok", "message": "Logging test"}
    
    # MCP OAuth protected resource metadata endpoint
    @app.get("/.well-known/oauth-protected-resource")
    async def oauth_protected_resource(request: Request):
        """Generate MCP protected resource metadata based on hostname with comprehensive logging."""
        try:
            # Extract client IP using centralized function
            client_ip = get_real_client_ip(request)
            
            logger.info(f"MCP metadata endpoint requested - IP: {client_ip}, Path: {request.url.path}")
            
            # Get hostname from request - check x-forwarded-host first (set by proxy)
            proxy_hostname = request.headers.get("x-forwarded-host", "").split(":")[0]
            if not proxy_hostname:
                # Fallback to host header
                proxy_hostname = request.headers.get("host", "").split(":")[0]
            if not proxy_hostname:
                logger.error(f"MCP metadata request failed - no host header, IP: {client_ip}")
                raise HTTPException(404, "No host header")
            
            logger.debug(f"MCP metadata hostname resolved: {proxy_hostname}")
            
            # Get proxy target
            logger.info(f"Looking up proxy target for hostname: {proxy_hostname}")
            # UnifiedStorage handles sync/async automatically - no fallback needed
            target = await request.app.state.storage.get_proxy_target(proxy_hostname)
            logger.info(f"Got proxy target: {target}")
            if not target:
                # Get available proxies for debugging
                available_proxies = []
                try:
                    proxy_list = await request.app.state.storage.list_proxy_targets()
                    available_proxies = [p.proxy_hostname for p in proxy_list][:10]
                except Exception:
                    pass
                
                logger.error(f"MCP metadata request failed - no proxy target configured for {proxy_hostname}")
                raise HTTPException(404, f"No proxy target configured for {proxy_hostname}")
            
            logger.debug(f"MCP metadata proxy target found for {proxy_hostname}")
            
            # Check if protected resource metadata is configured
            logger.info(f"Checking resource metadata - endpoint: {target.resource_endpoint}, scopes: {target.resource_scopes}")
            
            if not target.resource_endpoint:
                logger.warning(f"Protected resource metadata request failed - not configured for proxy {proxy_hostname}")
                raise HTTPException(404, "Protected resource metadata not configured for this proxy")
            
            # Build resource URI
            logger.info("Building resource URI")
            proto = request.headers.get("x-forwarded-proto", "https")
            resource_endpoint = target.resource_endpoint
            logger.info(f"Protocol: {proto}, hostname: {proxy_hostname}, endpoint: {resource_endpoint}")
            resource_uri = f"{proto}://{proxy_hostname}{resource_endpoint}"
            
            logger.debug(f"MCP metadata building resource URI: {resource_uri}")
            
            # Get authorization server URL
            logger.info(f"Getting auth servers - auth_enabled: {target.auth_enabled}, auth_proxy: {target.auth_proxy}")
            auth_servers = []
            if target.auth_enabled and target.auth_proxy:
                auth_servers.append(f"https://{target.auth_proxy}")
                logger.info(f"Added auth server: https://{target.auth_proxy}")
            
            # Build metadata response per RFC 9728
            logger.info("Building metadata response")
            resource_scopes = target.resource_scopes or ["mcp:read", "mcp:write"]
            logger.info(f"Resource scopes: {resource_scopes}")
            
            # Get bearer methods from metadata or use default
            bearer_methods = target.resource_bearer_methods or ["header"]
            
            # Get documentation suffix from metadata or use default
            doc_suffix = target.resource_documentation_suffix or "/docs"
            
            metadata = {
                "resource": resource_uri,
                "authorization_servers": auth_servers,
                "scopes_supported": resource_scopes,
                "bearer_methods_supported": bearer_methods,
                "resource_documentation": f"{resource_uri}{doc_suffix}"
            }
            logger.info(f"Created metadata dict: {metadata}")
            
            # Add JWKS URI if auth is enabled
            if auth_servers:
                metadata["jwks_uri"] = f"{auth_servers[0]}/jwks"
            
            # Add server info if configured
            if target.resource_server_info:
                logger.info(f"Adding server info: {target.resource_server_info}")
                metadata.update(target.resource_server_info)
            else:
                logger.info("No server info to add")
            
            # Add custom metadata if configured
            if target.resource_custom_metadata:
                logger.info(f"Adding custom metadata: {target.resource_custom_metadata}")
                metadata.update(target.resource_custom_metadata)
            
            logger.info(f"MCP metadata endpoint responding successfully for {proxy_hostname}")
            
            return metadata
        
        except HTTPException:
            # Re-raise HTTPException as-is
            raise
        except Exception as e:
            import traceback
            tb = traceback.format_exc()
            logger.error(f"Unexpected error in oauth-protected-resource endpoint: {str(e)}\n{tb}")
            raise HTTPException(500, "Internal Server Error")
    
    # Include OAuth protocol router (remains at root level for compliance)
    oauth_router = create_oauth_router(oauth_settings, oauth_redis_manager, auth_manager)
    app.include_router(oauth_router)
    logger.info("OAuth router included successfully")
    
    # Note: All routers are registered via the unified router registry
    # This happens after async components are attached in main.py or app.py
    
    return app